#+TITLE: S Linux From Scratch v7.7

* Preface
  Tks Gerard Beekmans, Matthew Burgess and Bruce Dubbs

** Foreword
My journey to learn and better understand Linux began over a decade ago,
back in 1998. I had just installed my first Linux distribution and had
quickly become intrigued with the whole concept and philosophy behind Linux.

There are always many ways to accomplish a single task. The same can be said
about Linux distributions. A great many have existed over the years. Some
still exist, some have morphed into something else, yet others have been
relegated to our memories. They all do things differently to suit the needs
of their target audience. Because so many different ways to acoomplish the
same end goal exist, I began to realize I no longer had to be limited by any
one implementation. Prior to discovering Linux, we simply put up with issues
in other Operating Systems as you had no choice. It was what it was, whether
you liked it or not. With linux, the concept of choice began to emerge. If
you didn't like something, you were free, even encouraged, to change it.

I tired a number of distributions and could not decide on any one. They were
great systems in their own right. It wasn't a matter of right and wrong
anymore. It had become a matter of personal taste. With all that choice 
available, it became apparent that there would not be a single system that
would be perfect for me. So I set out to create my own Linux system that
would fully conform to my personal preferences.

To truly make it my own system, I resolved to compile everything from source
code instead of using pre-compiled binary packages. This "perfect" Linux
system would have the strengths of various systems without their perceived
weaknesses. At first, the idea was rather daunting. I remained committed
to take the idea that such a system could be built. 

After sorting through issues such as circular dependencies and compile-time 
errors, I finally built a custom-built Linux system. It was fully operational
and perfectly usable like any of the other Linux systems out there at the
time. But it was my own creation. It was very staisfying to have put together
such a system myself. The only thing better would have been to create each
piece of software myself. This was the next best thing.

As I shared my goals and experiences with other members of the Linux communi-
ty, it became apparent that there was a sustained interest in these ideas.
It quickly became plain that such custom-built Linux systems serve not only
to meet user specific requirements, but also serve as an ideal learning
opportunity for programmers and system administrators to enhance their
Linux skills. Out of this broadened interest, the /Linux From Scratch Project/
was born.

This Linux From Scratch book is the central core around that project. It
provides the background and instructions necessary for you to design and
build your own system. while this book provides a template that will result
in a correctly working system, you are free to alter the instructions to 
suit yourself, which is, in part, an important part of this project. You
remain in control; we just lend a helping hand to get you started on your
own journey.

I sincerely hope you will have a great time working on your own Linux From
Scratch system and enjoy the numberous benefits of having a system that it 
truly your own.

** Audience
There are many reasons why you would want to read this book. One of the 
questions many people raise is, "why go through all the hassle of manually
building a Linux system from scratch when you can just download and install
an existing one?"

One important reason for this project's existence is to help you lean how
a Linux system works from the inside out. Building an LFS system helps 
demonstrate what makes Linux tick, and how things work together and depends
on each other. One of the best things that this learning experience can
provide is the ability to customize a Linux system to suit your own unique
needs.

Another key benefit of LFS is that it allows you to have more control over
the system without relying on someone else's Linux implementation. With
LFS, you are in the driver's seat and dictate every aspect of the system.

LFS allows you to create very compact Linux systems. When installing regular
distributions, you are often forced to install a great many programs which
are probably never used or understood. These programs waste resources. You
many argue that with today's hard drive and CPUs, such resources are no
longer a consideration. Sometimes, however, you are still constrained by size
considerations if nothing else. Think about bootable CDs, USB sticks, and
embedded systems. Those are areas where LFS can be beneficial.

Another advantage of a custom built Linux system is security. By compiling 
the entire system from source code, you are empowered to audit everything 
and apply all the security patches desired. It is no longer necessary to 
wait for somebody else to compile binary packages that fix a security hole.
Unless you examine the patch and implement it yourself, you have no gurantee
that the new binary package was built correctly and adequately fixes the 
problem.

There are too many other good reasons to build your own LFS system to list
them all here. In the end, education is by far the most powerful of reasons.
As you continue in your LFS experience, you will disover the power that
information and knowledge truly bring.
   
** LFS Target Architectures
The primary target architectures of LFS are the AMD/Intel x86(32-bit) and
x86_64(64-bit) CPUs. On the other hand, the instructions in this book are
also known to work, with some modifications, with the Power PC and ARM CPUs.
To build a system that utilizes on of these CPUs, the main prerequisite, in
addition to those on the next few pages, is an existing Linux system such as
an earlier LFS installation, Ubuntu, Read Hat/Fedora, SuSE, or other distri-
bution that targets the architecture that you have. Also note that a 32-bit
distribution can be installed and used as a host system on a 64-bit AMD/Intel
computer.

Some other facts about 64-bit systems need to be added here. When compared
to a 32-bit system, the sizes of executable programs are slightly larger
and the execution speeds are only slightly faster. For example, in a test
build of LFS-6.5 on a Core2Duo CPU based system, the following statistics
were measured:
#+BEGIN_SRC info
Architecture Build Time          Build Size
32-bit       198.5 minutes        648MB
64-bit       190.6 minutes        709MB
#+END_SRC
As you can see, the 64-bit build is only 4% faster and is 9% larger than the
32-bit build. The gain from going to a 64-bit system is relatively minimal.
Of course, if you have more than 4GB of RAM or want to manipulate data that
exceeds 4GB, the advantages of a 64-bit system are substantial.

The default 64-bit build that results from LFS is considered as "pure" 
64-bit system. That is, it supports 64-bit executables only. Building a 
"multi-lib" system requires compiling many applications twice, once for a 
32-bit system and once for a 64-bit system. This is not directly supported
in LFS because it would interfere with the educational objective of providing
the instructions needed for a straightforward base Linux system. You can 
refer to the /Cross Linux From Scratch project/ for this advanced topic.

There is one last comment about 64-bit systems. There are some older packages
that cannot currently be built in a "pure" 64-bit system or require speciali-
zed build instructions. Generally, these packages have some embedded 32-bit
specific assembly language instructions that fail when building on a 64-bit
system. This includes some Xorg drivers for some legacy video cards at
http://xorg.freedesktop.org/releases/individual/driver/
Many of these problems can be worked around, but may require some specialized
procedures or patches.
** LFS and Standards
The structure of LFS follows Linux standards as closely as possible. The
primary standsards are:
+ POSIX.1-2008.
+ Filesystem Hierarchy Standard version 3.0 Draft 1 (FHS)
+ Linux Standard Base (LSB) Specifications
  The LSB has five separate standards: Core, C++, Desktop, Runtime Languages,
  and Printing. In addition to generic requirements there are also architec-
  ture specific requirements. LFS attempts to conform to the architectures
  discussed in the previous section.
  
  Note:
  Many people do not agree with the requirements of the LSB. The main purpose
  of defining it is to ensure that propritary software will be able to be
  installed and run properly on a compliant system. Since LFS is source 
  based, the user has complete control over what packages are desired and 
  many choose not to install some packages that are specified by the LSB.

Creating a complete LFS system capable of passing the LSB certifications 
tests is possible, but not without many additional packages that are beyond
the scope of LFS. These additional packages have installation instructions
in BLFS.

*** Packages supplied by LFS needed to satisfy the LSB Requirements
LSB Core:                base, bc, binutils, coreutils, diffutils, file,
                         findutils, gawk, grep, gzip, m4, manDB, ncurses,
                         procps, psmisc, sed, shadown, tar, util-linux, zlib
LSB C++:                 gcc
LSB Desktop:             N/A
LSB Runtime languages:   Perl
LSB Printing:            N/A
LSB Multimedia:          N/A

*** Packages supplied by BLFS needed to satisfy the LSB Requirements
LSB Core:                at, batch, cpio, ed, fcrontab, initd-tools,
                         lsb_release, PAM, pax, sendmail, time
LSB C++:                 N/A
LSB Desktop:             atk, cairo, desktop-file-utils, freetype, fontconfig
                         glib2, GTK+2, icon-naming-utils, libjpeg, libpng,
                         libxml2, mesalib, pango, Qt4, xorg
LSB Runtime Languages:   Python
LSB Printing:            CUPS
LSB Multimedia:          alsa libraries, NSPR, NSS, OpenSSL, Java, xdg-utils

*** packages not supplied by LFS or BLFS needed to satisfy the LSB Requirements
LSB Core:                N/A
LSB C++:                 N/A
LSB Desktop              Qt3
LSB Runtime Languages:   N/A
LSB Printing             N/A
LSB Multimedia:          N/A

* Part I. Introduction
* Part II. Preparing for the build
* Part III. Building the LFS system
* Part IV. Appendices
